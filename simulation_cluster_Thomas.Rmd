---
title: "simulation_cluster_Thomas"
output: html_document
date: "2025-01-11"
---

```{r}
rm(list = ls())

library(dplyr)
library(ggplot2)

library(sampling)
library(MASS)

library(clusterGeneration)
library(mvtnorm)

library(survey)


```



## Paramètres de la simulation et création de la population

```{r}
set.seed(123)

# Étape 1 : Génération de la population globale
n_total <- 250000  # Nombre total d'individus

# Générer des coordonnées aléatoires dans un espace 2D (1000 x 1000)
population <- data.frame(
  id = 1:n_total,
  x = runif(n_total, min = 0, max = 1000),  # Coordonnées x
  y = runif(n_total, min = 0, max = 1000)   # Coordonnées y
)

# Étape 2 : Définition des centres des clusters de malades
n_centres <- 3  # Nombre de clusters
centres_malades <- data.frame(
  centre_id = 1:n_centres,
  x = runif(n_centres, min = 200, max = 800),  # Centres x
  y = runif(n_centres, min = 200, max = 800)   # Centres y
)

```


## Création des malades, à relancer pour chaque proportion de cas capté

```{r}
# Paramètres pour ajuster la proportion et la taille des clusters
prop_cluster <- 0 # Proportion des malades dans les clusters
mean_radius <- 80     # Rayon moyen des clusters

# Calcul du nombre total de malades
n_malades <- floor(250000 * 0.005)  # 0.5% de la population sont malades

# Étape 3 : Attribution des malades aux clusters ou au hasard
# 1. Attribution des malades aux clusters (proportion prop_cluster)
n_malades_clusters <- floor(n_malades * prop_cluster)

# Créer un vecteur de maladies initialement à 0 (pas malades)
population$malade <- 0

# Cas où prop_cluster = 0, attribuer aléatoirement tous les malades à la population entière
if (prop_cluster == 0) {
  indices_malades <- sample(population$id, n_malades)
  population$malade[indices_malades] <- 1
} else {
  # Fonction pour identifier les individus dans un rayon donné autour d'un centre
  identifie_individus_dans_cluster <- function(centre_x, centre_y, rayon) {
    distances <- sqrt((population$x - centre_x)^2 + (population$y - centre_y)^2)
    return(which(distances <= rayon))
  }

  # Liste des indices des malades dans les clusters
  indices_malades_clusters <- integer(0)

  # Pour répartir équitablement les malades dans chaque cluster
  malades_par_cluster <- floor(n_malades_clusters / n_centres)

  for (i in 1:n_centres) {
    # Identifier les individus dans le rayon autour du centre du cluster
    individus_dans_cluster <- identifie_individus_dans_cluster(centres_malades$x[i], centres_malades$y[i], mean_radius)

    # Si le nombre d'individus dans le rayon est suffisant, sélectionner aléatoirement
    if (length(individus_dans_cluster) >= malades_par_cluster) {
      malades_dans_cluster <- sample(individus_dans_cluster, malades_par_cluster)
      indices_malades_clusters <- c(indices_malades_clusters, malades_dans_cluster)
    }
  }

  # Mettre à jour les malades dans la population
  population$malade[indices_malades_clusters] <- 1

  # Créer la table "malade_cluster" 
  malades_clusters <- population[indices_malades_clusters, c("id", "x", "y")]

  # Attribution des malades restants de manière aléatoire en dehors des clusters
  individus_dans_les_clusters <- list()

  for (i in 1:n_centres) {
    individus_dans_cluster <- identifie_individus_dans_cluster(centres_malades$x[i], centres_malades$y[i], mean_radius)
    individus_dans_les_clusters[[i]] <- population[individus_dans_cluster, c("id", "x", "y")]
  }

  # Combiner les individus des clusters
  individus_dans_les_clusters <- do.call(rbind, individus_dans_les_clusters)

  # Identifier les individus hors clusters
  individus_hors_cluster <- population %>% 
    filter(!(id %in% individus_dans_les_clusters$id)) %>%
    distinct()

  # Attribution du caractère malade dans cette population hors clusters
  malades_hors_cluster <- sample(individus_hors_cluster$id, n_malades - n_malades_clusters)
  indices_hors_clusters <- c(indices_malades_clusters, malades_hors_cluster)

  # Assigner les malades hors des clusters
  population$malade[indices_hors_clusters] <- 1
}

# Étape 4 : Visualisation
library(ggplot2)

# Séparer les malades dans et hors clusters pour la visualisation
if (prop_cluster == 0) {
  # Tous les malades sont attribués aléatoirement, donc il n'y a pas de malades en clusters
  malades_clusters_plot <- data.frame(id = integer(0), x = numeric(0), y = numeric(0))  # Tableau vide
  malades_outside_plot <- subset(population, malade == 1)  # Tous les malades sont hors clusters
} else {
  malades_clusters_plot <- malades_clusters
  malades_outside_plot <- subset(population, malade == 1 & !(id %in% malades_clusters$id))
}

# Création du graphique
ggplot() +
  geom_point(data = malades_outside_plot, aes(x = x, y = y), color = "blue", size = 0.9, alpha = 0.7) +
  geom_point(data = malades_clusters_plot, aes(x = x, y = y), color = "red", size = 0.9, alpha = 0.7) +
  {if (prop_cluster > 0) geom_point(data = centres_malades, aes(x = x, y = y), color = "black", size = 0.5, shape = 8)} +
  labs(title = "Répartition des malades : clusters (rouge) et hors clusters (bleu)",
       x = "X", y = "Y") +
  coord_fixed(ratio = 1, xlim = c(0, 1000), ylim = c(0, 1000)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 16))




## Création des PSU


# Étape 4 : Création de PSU réguliers (15x15) dans l'espace 1000x1000
psu_size <- 15  

# Calculer les limites des PSU
psu_x_limits <- seq(0, 1000, by = 1000/psu_size)
psu_y_limits <- seq(0, 1000, by = 1000/psu_size)

# Attribuer chaque individu à une PSU
population$psu_x <- cut(population$x, breaks = psu_x_limits, labels = FALSE, include.lowest = TRUE)
population$psu_y <- cut(population$y, breaks = psu_y_limits, labels = FALSE, include.lowest = TRUE)


# Étape 5 : Créer un tableau récapitulatif du nombre d'individus et des malades par PSU
psu_counts <- population %>%
  group_by(psu_x, psu_y) %>%
  summarise(
    total_individus = n(),
    malades = sum(malade),
    .groups = "drop"
  ) 

# On rajoute la colonne pour identifier les PSU
psu_counts$PSU <- seq(1, 225, by = 1)

# Calcul du taux d'individu malades
psu_counts$Y_h <- psu_counts$malades / psu_counts$total_individus

# On détermine d'abord pour chaque PSU si elle est malade ou pas. Si la prévalence dans une PSU est supérieure à 0.5%, alors on dira que cette PSU est malade. Sinon, cette PSU n'est pas malade. 

psu_counts$PSU_malade <- psu_counts$Y_h > 0.005



## Détermination de l'ordre de visite des PSU 

## Chemin serpent 

# Création d'un chemin "serpent" pour parcourir les PSU
# D'abord on initialise un vecteur nul qui contiendra par la suite les PSU dans l'ordre de visite.
chemin <- NULL
# Ensuite, on va créer une boucle qui ajoute les PSU dans l'ordre selon si la ligne doit se parcourir de gauche à droite (pour les lignes ayant un numéro impair) ou de droite à gauche (pour les lignes ayant un numéro pair)
for (i in 1:psu_size) {
  if (i %% 2 == 1) {
    # Ligne impaire : de gauche à droite
    chemin <- c(chemin, seq((i-1) * psu_size + 1, i * psu_size))
  } else {
    # Ligne paire : de droite à gauche
    chemin <- c(chemin, seq(i * psu_size, (i-1) * psu_size + 1, by = -1))
  }
}
chemin # numéros des PSU dans l'ordre où ils devront être visités

chemin_mc_posa <- chemin
chemin_mc_cposa <- chemin


```


## Chemin serpent 
```{r}


# Création d'un chemin "serpent" pour parcourir les PSU
# D'abord on initialise un vecteur nul qui contiendra par la suite les PSU dans l'ordre de visite.
chemin <- NULL
# Ensuite, on va créer une boucle qui ajoute les PSU dans l'ordre selon si la ligne doit se parcourir de gauche à droite (pour les lignes ayant un numéro impair) ou de droite à gauche (pour les lignes ayant un numéro pair)
for (i in 1:psu_size) {
  if (i %% 2 == 1) {
    # Ligne impaire : de gauche à droite
    chemin <- c(chemin, seq((i-1) * psu_size + 1, i * psu_size))
  } else {
    # Ligne paire : de droite à gauche
    chemin <- c(chemin, seq(i * psu_size, (i-1) * psu_size + 1, by = -1))
  }
}
chemin # numéros des PSU dans l'ordre où ils devront être visités

chemin_mc_posa <- chemin
chemin_mc_cposa <- chemin

```


## Chemin GTRS

```{r}

# On va créer des blocs de taille 3*3 (c'est-à-dire que chaque bloc contient 9 PSU, et on a au total 5*5=25 blocs).
bloc_size <- 3
nb_blocs_par_ligne_ou_colonne <- psu_size / bloc_size

# On ajoute l'identifiant des blocs pour chaque case
# On utilisera l'opérateur %/% qui permet d'obtenir le quotient d'une division euclidienne
psu_bloc <- psu_counts %>%
  mutate(
    bloc_ligne_x = (psu_x - 1) %/% bloc_size + 1, # le numéro de ligne du bloc (entre 1 et 5)
    bloc_colonne_y = (psu_y - 1) %/% bloc_size + 1, # le numéro de colonne du bloc (entre 1 et 5)
    bloc_id = (bloc_ligne_x - 1) * nb_blocs_par_ligne_ou_colonne + bloc_colonne_y # le numéro du bloc entre 1 et 25 sachant qu'ils sont parcourus dans l'ordre de la lecture (c'est-à-dire de gauche à droite pour chaque ligne, de la ligne la plus haute à la ligne la plus basse)
  )

chemin_blocs <- NULL
# Ensuite, on va créer une boucle qui ajoute les blocs dans l'ordre selon si la ligne doit se parcourir de gauche à droite (pour les lignes ayant un numéro impair) ou de droite à gauche (pour les lignes ayant un numéro pair)
for (i in 1:5) {
  if (i %% 2 == 1) {
    # Ligne impaire : de gauche à droite
    chemin_blocs <- c(chemin_blocs, seq((i-1) * 5 + 1, i * 5))
  } else {
    # Ligne paire : de droite à gauche
    chemin_blocs <- c(chemin_blocs, seq(i * 5, (i-1) * 5 + 1, by = -1))
  }
}
chemin_blocs # numéros des blocs de 3*3 PSU dans l'ordre où ces blocs devront être visités
# cela correspond à l'ordre à utiliser pour parcourir les blocs (colonne bloc_id de la table psu_bloc)

# On définit l'ordre de parcours dans chaque bloc
psu_bloc <- psu_bloc %>%
  mutate(
    ordre_dans_le_bloc = case_when(
      psu_y %in% c(1, 4, 7, 10, 13) & psu_x %in% c(1, 4, 7, 10, 13) ~ 1,
      psu_y %in% c(1, 4, 7, 10, 13) & psu_x %in% c(2, 5, 8, 11, 14) ~ 2,
      psu_y %in% c(1, 4, 7, 10, 13) & psu_x %in% c(3, 6, 9, 12, 15) ~ 3,
      psu_y %in% c(2, 5, 8, 11, 14) & psu_x %in% c(3, 6, 9, 12, 15) ~ 4,      
      psu_y %in% c(2, 5, 8, 11, 14) & psu_x %in% c(2, 5, 8, 11, 14) ~ 5,
      psu_y %in% c(2, 5, 8, 11, 14) & psu_x %in% c(1, 4, 7, 10, 13) ~ 6,
      psu_y %in% c(3, 6, 9, 12, 15) & psu_x %in% c(1, 4, 7, 10, 13) ~ 7,
      psu_y %in% c(3, 6, 9, 12, 15) & psu_x %in% c(2, 5, 8, 11, 14) ~ 8,
      psu_y %in% c(3, 6, 9, 12, 15) & psu_x %in% c(3, 6, 9, 12, 15) ~ 9,
      TRUE ~ NA_real_ # Valeur par défaut si aucune condition n'est remplie
    )
  )

chemin <- NULL
for (i in chemin_blocs) {
  for (j in 1:9) {
    le_bon_PSU <- psu_bloc %>% 
      filter(bloc_id == i & ordre_dans_le_bloc == j)
    chemin <- c(chemin, le_bon_PSU$PSU)
  }
}

chemin_mc_posa <- chemin
chemin_mc_cposa <- chemin

```




```{r}
set.seed(123) 
n_iterations <- 1000

# Création d'une matrice pour stocker les résultats
resultats_simulation_posa_final <- data.frame(
  taille_echantillon = numeric(n_iterations),
  nombre_malades = numeric(n_iterations)
)

resultats_simulation_posa <- data.frame(
  taille_echantillon = numeric(n_iterations),
  nombre_malades = numeric(n_iterations)
)

```



## Simulation Monte-Carlo PoSA 

```{r}
i = 0
m_min = 19 # Nombre minimal de PSU sélectionnées
n_iterations = 1000

for (iteration in 1:n_iterations) {
  # Initialisation des données et des probabilités
  psu_counts <- psu_counts %>% 
    mutate(proba_initiale = total_individus / sum(total_individus) * m_min)
  
  # Initialisation des probabilités mises à jour (au départ égales aux probabilités initiales)
  psu_counts$proba_mise_a_jour <- psu_counts$proba_initiale
  psu_counts$psu_selectionne <- 0
  
  # Initialisation de la liste des PSU sélectionnées
  psu_selectionnees <- vector("list", length = psu_size * psu_size)
  
  # Initialisation de l'estimateur Pseudo-HT
  HT_pseudo = 0 
  V_HT_pseudo = 0
  N_total <- sum(psu_counts$total_individus)  # Taille totale de la population
  
  # Sélection de la première PSU avec sa probabilité initiale
  if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_initiale[1]) {
    psu_selectionnees[[1]] <- psu_counts[1, ]
    psu_counts$psu_selectionne[1] <- 1
    
    if (psu_counts$PSU_malade[1]) {
        psu_counts[2, "proba_mise_a_jour"] <- 1
      }
  }
  
  chemin_mc_posa_tempo <- chemin_mc_posa
  
  # Parcours des PSU pour sélection adaptative et mise à jour de HT_pseudo
  for (h in 2:224) { 
    PSU_actuelle <- chemin_mc_posa_tempo[h + 1]
    PSU_precedente <- chemin_mc_posa_tempo[h]
    
    # Mise à jour des probabilités des PSU voisines si la PSU précédente est malade
    if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_initiale[PSU_precedente]) {
      psu_counts$psu_selectionne[PSU_precedente] <- 1 
      psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente, ]
      
      if (psu_counts$PSU_malade[PSU_precedente]) {
        psu_counts[PSU_actuelle, "proba_mise_a_jour"] <- 1
      } } else {
      # Sélection avec la probabilité d'inclusion initiale ou mise à jour
      if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_mise_a_jour[PSU_precedente] & psu_counts$PSU_malade[PSU_precedente]) {
        psu_counts$psu_selectionne[PSU_precedente] <- 1
        psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente, ]
      }
    }
          
    
    # Définition de S_h : indicatrice de sélection
    Sh <- ifelse(!is.null(psu_selectionnees[[PSU_precedente]]), 1, 0)
    
    # Mise à jour séquentielle de l'estimateur Pseudo-HT uniquement si Sh = 1
    if (Sh == 1) {
      Yh = psu_counts[PSU_actuelle, "malades"] 
      pi_h_1 = psu_counts[PSU_actuelle, "proba_mise_a_jour"]
      
      if (pi_h_1 > 0) {
        HT_pseudo = HT_pseudo + (Yh * Sh) / pi_h_1
        V_HT_pseudo = V_HT_pseudo + (1 / pi_h_1) * (1 / pi_h_1 - 1) * Yh**2
      }
    }
  }
  
  # Cas particulier pour la dernière PSU (h = 225)
  if (h == 225) {
    if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_mise_a_jour[225]) {
      psu_counts$psu_selectionne[225] <- 1 
          
      # Vérification si la dernière PSU est malade
      if (psu_counts$PSU_malade[225]) {
          psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente,]
        }
      }
    }
  
  # Normalisation de l'estimateur Pseudo-HT
  Y_PHT = HT_pseudo / N_total
  V_PHT <- V_HT_pseudo / N_total**2

  # Calcul HT classique
  Y_HT <- sum(psu_counts$malades / psu_counts$proba_initiale) * 1 / 250000
  # Calcul de la variance exacte de l'estimateur HT
  #V_HT <- sum(outer(psu_counts$malades, psu_counts$malades, "*") / outer(psu_counts$proba_initiale, psu_counts$proba_initiale, "*")) - 
        (sum(psu_counts$malades / psu_counts$proba_initiale))^2
  #CV_HT <- sqrt(V_HT) / Y_HT # coefficient de variation
  CV_PHT <- sqrt(V_PHT) / Y_PHT
  
  # Comparaison PHT et HT
  #rapport_variances <- V_PHT / V_HT
  biais_relatif_PHT <- (Y_PHT - 0.005) / 0.005
  biais_relatif_HT <- (Y_HT - 0.005) / 0.005
  
  # Calcul des résultats pour cette itération
  m_ech <- nrow(as.data.frame(do.call(rbind, psu_selectionnees))) 
  # Obtention de la table liée à l'échantillon
  psu_counts_ech <- psu_counts %>% 
    filter(psu_selectionne == 1)
  
  # Enregistrement des résultats
  resultats_simulation_posa[iteration, "taille_echantillon"] <- sum(psu_counts_ech$total_individus)
  resultats_simulation_posa[iteration, "nombre_malades"] <- sum(psu_counts_ech$malades)
  resultats_simulation_posa[iteration, "m_ech_malades"] <- m_ech
  resultats_simulation_posa[iteration, "m_ech"] <- sum(psu_counts$psu_selectionne)
  resultats_simulation_posa[iteration, "Y_HT"] <- Y_HT
  resultats_simulation_posa[iteration, "Y_PHT"] <- Y_PHT
  #resultats_simulation_posa[iteration, "V_HT"] <- V_HT
  resultats_simulation_posa[iteration, "V_PHT"] <- V_PHT
  resultats_simulation_posa[iteration, "CV_PHT"] <- CV_PHT
  #resultats_simulation_posa[iteration, "CV_HT"] <- CV_HT
  #resultats_simulation_posa[iteration, "rapport_variances"] <- rapport_variances
  resultats_simulation_posa[iteration, "biais_relatif_PHT"] <- biais_relatif_PHT 
  resultats_simulation_posa[iteration, "biais_relatif_HT"] <- biais_relatif_HT
}


# Résumé des résultats
summary(resultats_simulation_posa)



```


## A update après chaque simulation lancée

```{r}
# A modifier en fonction du taux de clustering
resultats_simulation_posa$taux_cluster <- 0.5

# A la première itération
resultats_simulation_posa_final <- resultats_simulation_posa

# Pour le reste
resultats_simulation_posa_final <- rbind(resultats_simulation_posa_final,resultats_simulation_posa)
```

## Visualisation, très peu de différences sur les tailles d'échantillon, légère baisse du nombre de cas captés

```{r}
ggplot(resultats_simulation_posa_final, aes(x = as.factor(taux_cluster), y = taille_echantillon)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  labs(title = "Boxplot de tailles_echantillon par taux_cluster",
       x = "Taux Cluster",
       y = "Taille de l'échantillon") +
  theme_minimal()

ggplot(resultats_simulation_posa_final, aes(x = as.factor(taux_cluster), y = nombre_malades)) +
  geom_boxplot(fill = "salmon", color = "black") +
  labs(title = "Boxplot de nombre_malades par taux_cluster",
       x = "Taux Cluster",
       y = "Nombre de malades") +
  theme_minimal()

```






## Simulation de Monte-Carlo pour la méthode CPoSA (à optimiser, ~1h pour 2300 simulation)

```{r}
set.seed(123) 
n_iterations <- 30

# Création d'une matrice pour stocker les résultats
resultats_simulation_cposa_final <- data.frame(
  taille_echantillon = numeric(n_iterations),
  nombre_malades = numeric(n_iterations)
)

resultats_simulation_cposa <- data.frame(
  taille_echantillon = numeric(n_iterations),
  nombre_malades = numeric(n_iterations)
)

```


```{r}

i = 0

m_min = 21  # Nombre minimal de PSU sélectionnées
n_iterations <- 30

for (iteration in 1:n_iterations) {
  repeat {
    tryCatch({
      # Initialisation des données et des probabilités
      psu_counts <- psu_counts %>% 
        mutate(proba_initiale = total_individus / sum(total_individus) * m_min)
      
      # Initialisation des probabilités mises à jour (égales aux probabilités initiales au départ)
      psu_counts$proba_mise_a_jour <- psu_counts$proba_initiale
      psu_counts$psu_selectionne <- 0
      
      # Initialisation de la liste des PSU sélectionnées
      psu_selectionnees <- vector("list", length = psu_size * psu_size)
      
      # Sélection de la première PSU si h = 1
      if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_initiale[1]) {
        psu_counts$psu_selectionne[1] <- 1 
          
        # Vérification si la PSU sélectionnée est malade
        if (psu_counts$PSU_malade[1]) {
          psu_selectionnees[[1]] <- psu_counts[1, ]
          psu_counts[2, "proba_mise_a_jour"] <- 1
        } 
          
        # Mise à jour des probabilités pour les PSU suivantes
        for (j in 3:225) {
          psu_counts$proba_mise_a_jour[j] <- max(0, min(psu_counts$proba_mise_a_jour[j] - 
                                                   ((1 - psu_counts$proba_mise_a_jour[1]) / (225 - 1)), 1))
        }
        } else {
          for (j in 2:225) {
            psu_counts$proba_mise_a_jour[j] <- max(0, min(psu_counts$proba_mise_a_jour[j] + 
                                                   ((psu_counts$proba_mise_a_jour[1]) / (225 - 1)), 1))
          }
      }
      

      # Copie du chemin de marche aléatoire
      chemin_mc_cposa_tempo <- chemin_mc_cposa
      total_individus_selectionnes <- 0
      
      # Parcours des PSU pour sélection adaptative
      for (h in 2:224) { 
        PSU_actuelle <- chemin_mc_cposa_tempo[h + 1]
        PSU_precedente <- chemin_mc_cposa_tempo[h]
        
        # Sélection de la PSU précédente en fonction de sa probabilité
        if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_initiale[PSU_precedente]) {
          psu_counts$psu_selectionne[PSU_precedente] <- 1 
          
          # Vérification si la PSU sélectionnée est malade
          if (psu_counts$PSU_malade[PSU_precedente]) {
            psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente, ]
            psu_counts[PSU_actuelle, "proba_mise_a_jour"] <- 1
          }
          
          # Mise à jour des probabilités si h < 225
          if (h < 225) {
            for (j in (h+2):225) {
              psu_counts$proba_mise_a_jour[j] <- max(0, min(psu_counts$proba_mise_a_jour[j] - 
                                                 ((1 - psu_counts$proba_mise_a_jour[PSU_precedente]) / (225 - h)), 1))
            }
          }
        } else {
          # Mise à jour des probabilités si h < 225
          if (h < 225) {
            for (j in (h+1):225) {
              psu_counts$proba_mise_a_jour[j] <- max(0, min(psu_counts$proba_mise_a_jour[j] + 
                                                 (psu_counts$proba_mise_a_jour[PSU_precedente] / (225 - h)), 1))
            }
            # Sélection de la PSU précédente en fonction de sa probabilité
            if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_initiale[PSU_precedente] & psu_counts$PSU_malade[PSU_precedente]) {
              psu_counts$psu_selectionne[PSU_precedente] <- 1 
              psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente, ]
          } 
        }
        }
      }

      # Cas particulier pour la dernière PSU (h = 225)
      if (h == 225) {
        if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_mise_a_jour[225]) {
          psu_counts$psu_selectionne[225] <- 1 
          
          # Vérification si la dernière PSU est malade
          if (psu_counts$PSU_malade[225]) {
            psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente,]
          }
        }
      }
      
      # Calcul du nombre d'observations dans l'échantillon
      m_ech <- nrow(as.data.frame(do.call(rbind, psu_selectionnees))) 
      taille_echantillon <- sum(sapply(psu_selectionnees, function(psu) if (!is.null(psu)) psu$total_individus else 0))
      nombre_malades <- sum(sapply(psu_selectionnees, function(psu) if (!is.null(psu) && psu$PSU_malade) psu$malades else 0))
  
      
      # Obtention de la table des PSU sélectionnées
      psu_counts_ech <- psu_counts %>% filter(psu_selectionne == 1)
      
      # Enregistrement des résultats
      resultats_simulation_cposa[iteration, "taille_echantillon"] <- sum(psu_counts_ech$total_individus, na.rm = TRUE)
      resultats_simulation_cposa[iteration, "nombre_malades"] <- sum(psu_counts_ech$malades, na.rm = TRUE)
      resultats_simulation_cposa[iteration, "m_ech_malades"] <- m_ech
      resultats_simulation_cposa[iteration, "m_ech"] <- sum(psu_counts$psu_selectionne, na.rm = TRUE)
      
      table(psu_counts$psu_selectionne)
      
      break # Sortie du repeat si aucune erreur

    }, error = function(e) {
      # Relance de l'itération en cas d'erreur sans affichage de message
    })
  }
}




# Résumé des résultats
summary(resultats_simulation_cposa)

```

## A update après chaque simulation lancée

```{r}
# A modifier en fonction du taux de clustering
resultats_simulation_cposa$taux_cluster <- 0.5

# A la première itération
resultats_simulation_cposa_final <- resultats_simulation_cposa

# Pour le reste
resultats_simulation_cposa_final <- rbind(resultats_simulation_cposa_final,resultats_simulation_cposa)
```

## Visualisation, presque aucune différence peut importe le taux de cluster

```{r}
ggplot(resultats_simulation_cposa_final, aes(x = as.factor(taux_cluster), y = taille_echantillon)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  labs(title = "Boxplot de tailles_echantillon par taux_cluster",
       x = "Taux Cluster",
       y = "Taille de l'échantillon") +
  theme_minimal()

ggplot(resultats_simulation_cposa_final, aes(x = as.factor(taux_cluster), y = nombre_malades)) +
  geom_boxplot(fill = "salmon", color = "black") +
  labs(title = "Boxplot de nombre_malades par taux_cluster",
       x = "Taux Cluster",
       y = "Nombre de malades") +
  theme_minimal()


```





## Calcul du coefficient de variation inter-PSU k

```{r}
# Prévalence dans la population
Y_barre <- nrow(malades) / nrow(population)

# On ajoute à la table psu_counts la colonne Y_h qui correspond à la prévalence dans la PSU h
psu_counts$Y_h <- psu_counts$malades / psu_counts$total_individus

# On calcule ensuite la variance de (Y_h)^barre avec la formule donnée page 22 de l'article
Var_Yh_barre <- 1 / n_total * sum( ((psu_counts$Y_h - Y_barre)**2) * psu_counts$total_individus )

# Puis on détermine k avec la formule page 22 de l'article
k <- sqrt(Var_Yh_barre) / Y_barre
```

```{r}
# On peut regarder combien de PSU sont sélectionnées
sum(sapply(psu_selectionnees, function(x) !is.null(x) && nrow(x) > 0))
```

```{r}
# On ne garde que les lignes effectivement sélectionnées
psu_selectionnees <- do.call(rbind, psu_selectionnees)

# On affiche ces PSU
psu_selectionnees
```


## Plot global PoSA vs CPoSA

```{r}
library(ggplot2)

# Ajouter une colonne pour identifier les groupes (PoSA ou CPoSA)
resultats_simulation_posa_final$groupe <- "PoSA"
resultats_simulation_cposa_final$groupe <- "CPoSA"

# Combiner les deux datasets
resultats_combines <- rbind(resultats_simulation_posa_final, resultats_simulation_cposa_final)

# Fixer l'ordre des groupes (PoSA avant CPoSA)
resultats_combines$groupe <- factor(resultats_combines$groupe, levels = c("PoSA", "CPoSA"))

# Graphique pour la taille de l'échantillon
plot_taille_nwho <- ggplot(resultats_combines, aes(x = as.factor(taux_cluster), y = taille_echantillon, fill = groupe)) +
  geom_boxplot(position = position_dodge(0.8), color = "black") +
  labs(title = "Boxplot de la taille de l'échantillon par taux_cluster : n_min = 0.7 n_who",
       x = "Taux Cluster",
       y = "Taille de l'échantillon") +
  scale_fill_manual(values = c("PoSA" = "skyblue", "CPoSA" = "steelblue")) +
  theme_minimal()

# Graphique pour le nombre de malades
plot_malades_nwho <- ggplot(resultats_combines, aes(x = as.factor(taux_cluster), y = nombre_malades, fill = groupe)) +
  geom_boxplot(position = position_dodge(0.8), color = "black") +
  labs(title = "Boxplot du nombre de malades par taux_cluster : n_min = 0.7 n_who",
       x = "Taux Cluster",
       y = "Nombre de malades") +
  scale_fill_manual(values = c("PoSA" = "salmon", "CPoSA" = "darkred")) +
  theme_minimal()

# Affichage des deux graphiques
plot_taille_08_nwho
plot_malades_08_nwho
plot_taille_07_nwho
plot_malades_07_nwho
plot_taille_nwho
plot_malades_nwho

```

```{r}
install.packages("patchwork")
library(patchwork)

# Combinaison des graphiques 
combined_plot <- 
  (plot_taille_07_nwho + plot_taille_08_nwho + plot_taille_nwho)  

combined_plot_malades <-
  (plot_malades_07_nwho + plot_malades_08_nwho + plot_malades_nwho)

combined_plot_gtrs <- 
  (plot_taille_07_nwho_gtrs + plot_taille_08_nwho_gtrs + plot_taille_nwho_gtrs)

combined_plot_malades_gtrs <-
  (plot_malades_07_nwho_gtrs + plot_malades_08_nwho_gtrs + plot_malades_nwho_gtrs)

final_combined_plot <- (combined_plot / combined_plot_malades) + 
  plot_layout(heights = c(1.5, 1)) # Ajuste la hauteur relative des sections

final_combined_plot


# Affichage du graphique combiné
plot(combined_plot)
plot(combined_plot_gtrs)
plot(combined_plot_malades)
plot(combined_plot_malades_gtrs)

# Sauvegarde du graphique combiné
ggsave("final_combined_plot.png", combined_plot, width = 12, height = 8)

```


## Sondage proprotionnel à la taille

```{r}

n_min <- 19

# Initialisation des données et des probabilités
psu_counts <- psu_counts %>% 
  mutate(proba_initiale = total_individus / sum(total_individus) * n_min)

psu_counts$weights <- 1 / psu_counts$proba_initiale



# Fonction pour le tirage de Poisson
UPpoisson <- function(probs) {
  # Tirage binaire selon les probabilités initiales
  rbinom(length(probs), size = 1, prob = probs)
}

# Simulation de Monte-Carlo
set.seed(123)  # Pour reproductibilité
n_simulations <- 5000  # Nombre de simulations

# Stocker les résultats des simulations
results <- replicate(n_simulations, {
  # Tirage de Poisson
  ind_tires <- UPpoisson(psu_counts$proba_initiale)
  
  # Filtrer les PSU sélectionnés
  psu_counts_simple <- psu_counts[ind_tires == 1, ]
  m_ech <- nrow(psu_counts_simple)
  
  # Total d'individus
  total_individus <- sum(psu_counts_simple$total_individus)
  
  # Filtrer pour PSU_malade == TRUE
  psu_counts_simple_filtrer <- psu_counts_simple %>%
    filter(PSU_malade == TRUE)
  
  # Total de malades
  total_malades <- sum(psu_counts_simple_filtrer$malades)
  
  # Retourner les résultats
  c(total_individus, total_malades, m_ech)
})

# Transposer et convertir les résultats en data.frame
results_df <- as.data.frame(t(results))
colnames(results_df) <- c("Total_Individus", "Total_Malades", "m_ech")

# Résumé des résultats
summary_results <- results_df %>%
  summarise(
    taille_echantillon = mean(Total_Individus),
    nombres_malades = mean(Total_Malades),
    m_ech = mean(m_ech)
  )

# Afficher les résultats résumés
summary_results

```

```{r}
# A modifier en fonction du taux de clustering
results_df$taux_cluster <- 0.7

# A la première itération
resultats_simulation_prop_final <- results_df

# Pour le reste
resultats_simulation_prop_final <- rbind(resultats_simulation_prop_final,results_df)


```

```{r}
# Graphique pour Total_Individus
plot_total_individus_nwho <- ggplot(resultats_simulation_prop_final, aes(x = as.factor(taux_cluster), y = Total_Individus)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  labs(
    title = "Boxplot du total d'individus par taux_cluster",
    x = "Taux Cluster",
    y = "Total d'individus"
  ) +
  theme_minimal()

# Graphique pour Total_Malades
plot_total_malades_nwho <- ggplot(resultats_simulation_prop_final, aes(x = as.factor(taux_cluster), y = Total_Malades)) +
  geom_boxplot(fill = "salmon", color = "black") +
  labs(
    title = "Boxplot du total de malades par taux_cluster",
    x = "Taux Cluster",
    y = "Total de malades"
  ) +
  theme_minimal()

# Combinaison des graphiques 
combined_plot <- 
  (plot_total_individus_07_nwho + plot_total_individus_08_nwho + plot_total_individus_nwho) /  # Ligne des tailles
  (plot_total_malades_07_nwho + plot_total_malades_08_nwho + plot_total_malades_nwho)  # Ligne des malades

# Affichage du graphique combiné
plot(combined_plot)

# Affichage des graphiques
print(plot_total_individus)
print(plot_total_malades)


```




## Comparaison CPoSA avec un sondage proportionnel à la taille

```{r}

stats_CPoSA <- resultats_simulation_cposa_final %>% 
  reframe(rate_postive_case = (nombre_malades / taille_echantillon) * 100, 
            accuracy_final_estimation = sqrt(((nombre_malades / taille_echantillon) - 0.005)**2),
            final_sample_size = taille_echantillon,
            cost_par_case_detected = 2900000 + 18900*m_ech + m_ech*6.5*mean(psu_counts$total_individus),
          taux_cluster)

stats_prop <- resultats_simulation_prop_final %>% 
  filter(Total_Malades != 0) %>% 
  reframe(rate_postive_case = (Total_Malades / Total_Individus) * 100, 
            accuracy_final_estimation = sqrt(((Total_Malades / Total_Individus) / 100)**2),
            final_sample_size = Total_Individus,
            cost_par_case_detected = 2900000 + 18900*m_ech + m_ech*6.5*mean(psu_counts$total_individus),
          taux_cluster)

stats_prop <- stats_prop[c(1:20,5001:5020,12001:12020,17001:17020,22001:22020,27001:27020),]

comparaison <- stats_CPoSA / stats_prop

valeurs <- c(0.01, 0.3, 0.4, 0.5, 0.6, 0.7)

# Mise à jour des valeurs de comparaison$taux_cluster
for (i in 1:6) {
  comparaison$taux_cluster[((i - 1) * 20 + 1):(i * 20)] <- valeurs[i]
}

comparaison <- comparaison %>% 
  group_by(taux_cluster) %>% 
  summarise(across(everything(), mean, na.rm = TRUE))

variables_a_visualiser <- setdiff(names(comparaison), "taux_cluster")

# Fonction pour créer un graphique avec un paramètre de nom d'axe Y et personnalisation de l'axe X
create_plot <- function(data, var, y_label) {
  ggplot(data, aes(x = taux_cluster, y = .data[[var]])) + 
    geom_line() + 
    geom_hline(yintercept = 1, linetype = "dashed", color = "red") + # Ajoute une ligne horizontale en pointillé à y = 1
    labs(x = "Taux Cluster", y = y_label, title = paste("Graphique de", var)) + 
    theme_minimal() +
    theme(
      panel.border = element_rect(color = "black", fill = NA, size = 1), # Délimite les bords du graphique
      panel.grid.major = element_line(color = "grey80", size = 0.5), # Ajoute des lignes de grille
      panel.grid.minor = element_blank(), # Enlève les lignes de grille mineures
      axis.text.x = element_text(angle = 0, hjust = 0.5) # Ajuste l'orientation des textes sur l'axe X
    ) +
    scale_x_continuous(
      breaks = c(0, 0.3, 0.4, 0.5, 0.6, 0.7), # Spécifie les ticks que tu veux afficher
      labels = c("0", "0.3", "0.4", "0.5", "0.6", "0.7"), # Labels personnalisés
      expand = c(0, 0) # Enlève les marges supplémentaires autour de l'axe X
    )
}

# Liste des noms d'axes Y personnalisés
y_labels <- c(
  "Ability to detect positive cases",
  "Accuracy of Final Estimate",
  "Final Sample Size",
  "Cost per Case Detected"
)


# Créer un graphique pour chaque variable
plots <- lapply(variables_a_visualiser, function(var) {
  # On utilise le label correspondant pour chaque variable
  y_label <- y_labels[which(variables_a_visualiser == var)]
  create_plot(comparaison, var, y_label)
})

# Affichage des graphiques
for (i in seq_along(plots)) {
  print(plots[[i]])
}


```










## Plot global PoSA vs CPoSA vs prop

```{r}
library(ggplot2)

colnames(resultats_simulation_prop_final)[1] <- "taille_echantillon"
colnames(resultats_simulation_prop_final)[2] <- "nombre_malades"

# Ajouter une colonne pour identifier les groupes 
resultats_simulation_prop_final$groupe <- "Prop"

# Combiner les deux datasets
resultats_combines_total <- rbind(resultats_combines, resultats_simulation_prop_final)

# Fixer l'ordre des groupes (PoSA avant CPoSA)
resultats_combines_total$groupe <- factor(resultats_combines$groupe, levels = c("PoSA", "CPoSA","Prop"))

# Graphique pour la taille de l'échantillon
plot_taille_nwho <- ggplot(resultats_combines_total, aes(x = as.factor(taux_cluster), y = taille_echantillon, fill = groupe)) +
  geom_boxplot(position = position_dodge(0.8), color = "black") +
  labs(title = "Boxplot de la taille de l'échantillon par taux_cluster : n_min = 0.7 n_who",
       x = "Taux Cluster",
       y = "Taille de l'échantillon") +
  scale_fill_manual(values = c("PoSA" = "skyblue", "CPoSA" = "steelblue")) +
  theme_minimal()

# Graphique pour le nombre de malades
plot_malades_nwho <- ggplot(resultats_combines, aes(x = as.factor(taux_cluster), y = nombre_malades, fill = groupe)) +
  geom_boxplot(position = position_dodge(0.8), color = "black") +
  labs(title = "Boxplot du nombre de malades par taux_cluster : n_min = 0.7 n_who",
       x = "Taux Cluster",
       y = "Nombre de malades") +
  scale_fill_manual(values = c("PoSA" = "salmon", "CPoSA" = "darkred")) +
  theme_minimal()

```



# Vérification du calcul des poids CPoSA

```{r}

# n_min = 19, prop_cluster = 0.01, mean_radius = 100, chemin GTRS

proba_CPoSA <- psu_counts$proba_mise_a_jour
psu_selectionnees_CPoSA <- psu_selectionnees

# n_min = 19, prop_cluster = 0.5, mean_radius = 100, chemin GTRS

proba_CPoSA_2 <- psu_counts$proba_mise_a_jour
psu_selectionnees_CPoSA_2 <- psu_selectionnees



```



































```{r}
set.seed(123) 
n_iterations <- 1000

# Création d'une matrice pour stocker les résultats
resultats_simulation_posa_final <- data.frame(
  taille_echantillon = numeric(n_iterations),
  nombre_malades = numeric(n_iterations)
)

resultats_simulation_posa <- data.frame(
  taille_echantillon = numeric(n_iterations),
  nombre_malades = numeric(n_iterations)
)

```


## Simulation Monte-Carlo PoSA 

```{r}
i = 0
m_min = 19 # Nombre minimal de PSU sélectionnées


for (iteration in 1:n_iterations) {
  # Initialisation des données et des probabilités
  psu_counts <- psu_counts %>% 
    mutate(proba_initiale = total_individus / sum(total_individus) * m_min)
  
  # Initialisation des probabilités mises à jour (au départ égales aux probabilités initiales)
  psu_counts$proba_mise_a_jour <- psu_counts$proba_initiale
  psu_counts$psu_selectionne <- 0
  
  # Initialisation de la liste des PSU sélectionnées
  psu_selectionnees <- vector("list", length = psu_size * psu_size)
  
  # Initialisation de l'estimateur Pseudo-HT
  HT_pseudo = 0 
  V_HT_pseudo = 0
  N_total <- sum(psu_counts$total_individus)  # Taille totale de la population
  
  # Sélection de la première PSU avec sa probabilité initiale
  if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_initiale[1]) {
    psu_selectionnees[[1]] <- psu_counts[1, ]
    psu_counts$psu_selectionne[1] <- 1
    
    if (psu_counts$PSU_malade[1]) {
        psu_counts[2, "proba_mise_a_jour"] <- 1
      }
  }
  
  chemin_mc_posa_tempo <- chemin_mc_posa
  
  # Parcours des PSU pour sélection adaptative et mise à jour de HT_pseudo
  for (h in 2:224) { 
    PSU_actuelle <- chemin_mc_posa_tempo[h + 1]
    PSU_precedente <- chemin_mc_posa_tempo[h]
    
    # Mise à jour des probabilités des PSU voisines si la PSU précédente est malade
    if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_initiale[PSU_precedente]) {
      psu_counts$psu_selectionne[PSU_precedente] <- 1 
      psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente, ]
      
      if (psu_counts$PSU_malade[PSU_precedente]) {
        psu_counts[PSU_actuelle, "proba_mise_a_jour"] <- 1
      } } else {
      # Sélection avec la probabilité d'inclusion initiale ou mise à jour
      if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_mise_a_jour[PSU_precedente] & psu_counts$PSU_malade[PSU_precedente]) {
        psu_counts$psu_selectionne[PSU_precedente] <- 1
        psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente, ]
      }
    }
          
    
    # Définition de S_h : indicatrice de sélection
    Sh <- ifelse(!is.null(psu_selectionnees[[PSU_precedente]]), 1, 0)
    
    # Mise à jour séquentielle de l'estimateur Pseudo-HT uniquement si Sh = 1
    if (Sh == 1) {
      Yh = psu_counts[PSU_actuelle, "malades"] 
      pi_h_1 = psu_counts[PSU_actuelle, "proba_mise_a_jour"]
      
      if (pi_h_1 > 0) {
        HT_pseudo = HT_pseudo + (Yh * Sh) / pi_h_1
        V_HT_pseudo = V_HT_pseudo + (1 / pi_h_1) * (1 / pi_h_1 - 1) * Yh**2
      }
    }
  }
  
  # Cas particulier pour la dernière PSU (h = 225)
  if (h == 225) {
    if (runif(n = 1, min = 0, max = 1) < psu_counts$proba_mise_a_jour[225]) {
      psu_counts$psu_selectionne[225] <- 1 
          
      # Vérification si la dernière PSU est malade
      if (psu_counts$PSU_malade[225]) {
          psu_selectionnees[[PSU_precedente]] <- psu_counts[PSU_precedente,]
        }
      }
    }
  
  # Normalisation de l'estimateur Pseudo-HT
  Y_PHT = HT_pseudo / N_total
  V_PHT <- V_HT_pseudo / N_total**2

  # Calcul HT classique
  Y_HT <- sum(psu_counts$malades / psu_counts$proba_initiale) * 1 / 250000
  # Calcul de la variance exacte de l'estimateur HT
  #V_HT <- sum(outer(psu_counts$malades, psu_counts$malades, "*") / outer(psu_counts$proba_initiale, psu_counts$proba_initiale, "*")) - 
        (sum(psu_counts$malades / psu_counts$proba_initiale))^2
  #CV_HT <- sqrt(V_HT) / Y_HT # coefficient de variation
  CV_PHT <- sqrt(V_PHT) / Y_PHT
  
  # Comparaison PHT et HT
  #rapport_variances <- V_PHT / V_HT
  biais_relatif_PHT <- (Y_PHT - 0.005) / 0.005
  biais_relatif_HT <- (Y_HT - 0.005) / 0.005
  
  # Calcul des résultats pour cette itération
  m_ech <- nrow(as.data.frame(do.call(rbind, psu_selectionnees))) 
  # Obtention de la table liée à l'échantillon
  psu_counts_ech <- psu_counts %>% 
    filter(psu_selectionne == 1)
  
  # Enregistrement des résultats
  resultats_simulation_posa[iteration, "taille_echantillon"] <- sum(psu_counts_ech$total_individus)
  resultats_simulation_posa[iteration, "nombre_malades"] <- sum(psu_counts_ech$malades)
  resultats_simulation_posa[iteration, "m_ech_malades"] <- m_ech
  resultats_simulation_posa[iteration, "m_ech"] <- sum(psu_counts$psu_selectionne)
  resultats_simulation_posa[iteration, "Y_HT"] <- Y_HT
  resultats_simulation_posa[iteration, "Y_PHT"] <- Y_PHT
  #resultats_simulation_posa[iteration, "V_HT"] <- V_HT
  resultats_simulation_posa[iteration, "V_PHT"] <- V_PHT
  resultats_simulation_posa[iteration, "CV_PHT"] <- CV_PHT
  #resultats_simulation_posa[iteration, "CV_HT"] <- CV_HT
  #resultats_simulation_posa[iteration, "rapport_variances"] <- rapport_variances
  resultats_simulation_posa[iteration, "biais_relatif_PHT"] <- biais_relatif_PHT 
  resultats_simulation_posa[iteration, "biais_relatif_HT"] <- biais_relatif_HT
}


# Résumé des résultats
summary(resultats_simulation_posa)



```

## A update après chaque simulation lancée

```{r}
# A modifier en fonction du taux de clustering
resultats_simulation_posa$taux_cluster <- 0.7

# A la première itération
resultats_simulation_posa_final <- resultats_simulation_posa

# Pour le reste
resultats_simulation_posa_final <- rbind(resultats_simulation_posa_final,resultats_simulation_posa)
```

```{r}
plot_taille_ech_08_nwho_posa <- ggplot(resultats_simulation_posa_final, aes(x = as.factor(taux_cluster), y = taille_echantillon)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  labs(title = "Boxplot de tailles_echantillon par taux_cluster",
       x = "Taux Cluster",
       y = "Taille de l'échantillon") +
  theme_minimal()

plot_malades_08_nwho_posa <- ggplot(resultats_simulation_posa_final, aes(x = as.factor(taux_cluster), y = nombre_malades)) +
  geom_boxplot(fill = "salmon", color = "black") +
  labs(title = "Boxplot de nombre_malades par taux_cluster",
       x = "Taux Cluster",
       y = "Nombre de malades") +
  theme_minimal()

```